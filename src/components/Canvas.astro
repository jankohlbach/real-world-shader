<script>
  import type { PlaneParams } from 'curtainsjs';

  import { Curtains, Plane, Vec2 } from 'curtainsjs';
  import { gsap } from 'gsap';
  import { CustomEase } from 'gsap/all';

  import { lenis } from '../scripts/scroll';
  import { lerp, hasHover } from '../scripts/utils';
  import baseVertexShader from '../shader/vertex.glsl';
  import baseFragmentShader from '../shader/fragment.glsl';

  interface CustomUserData {
    mousePosCurrent: Vec2;
    mousePosTarget: Vec2;
    wasMouseInside?: boolean;
  }

  type CustomPlane = Plane & { userData: CustomUserData };

  const shaderFiles = import.meta.glob(['../shader/**/*.glsl'], {
    eager: true,
  });

  const findShaderFiles = (shader: string) => {
    return {
      vertex: (
        shaderFiles[`../shader/${shader}/vertex.glsl`] as {
          default: string | undefined;
        }
      )?.default,
      fragment: (
        shaderFiles[`../shader/${shader}/fragment.glsl`] as {
          default: string | undefined;
        }
      )?.default,
    };
  };

  window.addEventListener('load', () => {
    gsap.registerPlugin(CustomEase);

    const supportsHover = hasHover();
    const simulatedCursor = {
      enabled: !supportsHover,
      time: 0,
      baseSpeed: 1.2,
      amplitude: { x: 0.3, y: 0.2 },
      frequency: { x: 0.8, y: 1.0 },
      offset: { x: 0, y: Math.PI * 0.3 },
      center: { x: 0.5, y: 0.5 },
    };

    const scroll = {
      velocity: 0,
    };
    const mouse = {
      posTarget: new Vec2(0.5, 0.5),
      lerp: 0.05,
    };
    const startTime = performance.now();
    const planes: CustomPlane[] = [];

    const curtains = new Curtains({
      container: document.querySelector('[data-js="canvas"]') || undefined,
      pixelRatio: Math.min(2, window.devicePixelRatio),
      watchScroll: false,
    });

    curtains
      .onError(() => {
        document.body.classList.add('no-curtains');
      })
      .onContextLost(() => {
        curtains.restoreContext();
      });

    const planeElements = document.querySelectorAll('[data-canvas]');

    const params: PlaneParams = {
      vertexShader: baseVertexShader,
      fragmentShader: baseFragmentShader,
      widthSegments: 100,
      heightSegments: 100,
      transparent: true,
      uniforms: {
        aspectRatio: {
          name: 'uAspectRatio',
          type: '1f',
          value: 1.0,
        },
        time: {
          name: 'uTime',
          type: '1f',
          value: 0.0,
        },
        scrollVelocity: {
          name: 'uScrollVelocity',
          type: '1f',
          value: 0.0,
        },
        mouseEnter: {
          name: 'uMouseEnter',
          type: '1f',
          value: 0.0,
        },
        mouseOverPos: {
          name: 'uMouseOverPos',
          type: '2f',
          value: new Vec2(0.5, 0.5),
        },
      },
    };

    planeElements.forEach((planeElement) => {
      const shader = planeElement.getAttribute('data-shader');

      if (shader) {
        const foundShaderFiles = findShaderFiles(shader);

        if (
          foundShaderFiles &&
          foundShaderFiles.vertex &&
          foundShaderFiles.fragment
        ) {
          params.vertexShader = foundShaderFiles.vertex;
          params.fragmentShader = foundShaderFiles.fragment;
        } else {
          params.vertexShader = baseVertexShader;
          params.fragmentShader = baseFragmentShader;
        }
      }

      const plane = new Plane(curtains, planeElement, params) as CustomPlane;
      plane.userData.mousePosCurrent = new Vec2(0.5, 0.5);
      plane.userData.mousePosTarget = new Vec2(0.5, 0.5);
      plane.userData.wasMouseInside = false;
      planes.push(plane);

      planeElement.addEventListener('mouseenter', () => {
        gsap.to(plane.uniforms.mouseEnter, {
          value: 1.0,
          duration: 0.6,
          ease: CustomEase.create('custom', '0.4, 0, 0.2, 1'),
        });
      });
      planeElement.addEventListener('mouseleave', () => {
        gsap.to(plane.uniforms.mouseEnter, {
          value: 0.0,
          duration: 0.6,
          ease: CustomEase.create('custom', '0.4, 0, 0.2, 1'),
        });
      });

      plane.onRender(() => {
        const currentTime = performance.now();
        const elapsedTime = (currentTime - startTime) / 1000;

        if (simulatedCursor.enabled) {
          simulatedCursor.time = elapsedTime * simulatedCursor.baseSpeed;

          const x =
            simulatedCursor.center.x +
            Math.sin(
              simulatedCursor.time * simulatedCursor.frequency.x +
                simulatedCursor.offset.x,
            ) *
              simulatedCursor.amplitude.x +
            Math.sin(
              simulatedCursor.time * simulatedCursor.frequency.x * 0.7 +
                simulatedCursor.offset.x * 1.3,
            ) *
              simulatedCursor.amplitude.x *
              0.3;

          const y =
            simulatedCursor.center.y +
            Math.sin(
              simulatedCursor.time * simulatedCursor.frequency.y +
                simulatedCursor.offset.y,
            ) *
              simulatedCursor.amplitude.y +
            Math.cos(
              simulatedCursor.time * simulatedCursor.frequency.y * 0.9 +
                simulatedCursor.offset.y * 0.8,
            ) *
              simulatedCursor.amplitude.y *
              0.4;

          mouse.posTarget.set(
            Math.max(0, Math.min(window.innerWidth, x * window.innerWidth)),
            Math.max(0, Math.min(window.innerHeight, y * window.innerHeight)),
          );

          const planeRect = plane.htmlElement.getBoundingClientRect();
          const isInside =
            mouse.posTarget.x >= planeRect.left &&
            mouse.posTarget.x <= planeRect.right &&
            mouse.posTarget.y >= planeRect.top &&
            mouse.posTarget.y <= planeRect.bottom;

          const wasInside = plane.userData.wasMouseInside || false;

          if (isInside && !wasInside) {
            gsap.to(plane.uniforms.mouseEnter, {
              value: 1.0,
              duration: 0.6,
              ease: CustomEase.create('custom', '0.4, 0, 0.2, 1'),
            });
          } else if (!isInside && wasInside) {
            gsap.to(plane.uniforms.mouseEnter, {
              value: 0.0,
              duration: 0.6,
              ease: CustomEase.create('custom', '0.4, 0, 0.2, 1'),
            });
          }

          plane.userData.wasMouseInside = isInside;

          // TODO: more beautiful cursor (svg) and only show when hover effects section is visible
          const fakeCursor: HTMLElement | null =
            document.querySelector('.fake-cursor');
          fakeCursor?.style.setProperty('--cursor-x', x.toString());
          fakeCursor?.style.setProperty('--cursor-y', y.toString());
        }

        plane.userData.mousePosTarget = plane.mouseToPlaneCoords(
          mouse.posTarget,
        );
        plane.userData.mousePosCurrent.x = lerp(
          plane.userData.mousePosCurrent.x,
          plane.userData.mousePosTarget.x,
          mouse.lerp,
        );
        plane.userData.mousePosCurrent.y = lerp(
          plane.userData.mousePosCurrent.y,
          plane.userData.mousePosTarget.y,
          mouse.lerp,
        );

        plane.uniforms.aspectRatio.value =
          plane.getBoundingRect().width / plane.getBoundingRect().height;
        plane.uniforms.time.value = elapsedTime;
        plane.uniforms.scrollVelocity.value = scroll.velocity;
        plane.uniforms.mouseOverPos.value = plane.userData.mousePosCurrent;
      });
    });

    lenis.on('scroll', (e) => {
      curtains.updateScrollValues(window.scrollX, window.scrollY);
      scroll.velocity = e.velocity;
    });

    if (supportsHover) {
      window.addEventListener('mousemove', (e) => {
        mouse.posTarget.set(e.clientX, e.clientY);
      });
    }
  });
</script>

<div class="canvas" data-js="canvas"></div>
<!-- TODO -->
<div class="fake-cursor"></div>

<style lang="scss">
  .canvas {
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    z-index: var(--zi-canvas);
    pointer-events: none;
  }

  // TODO
  .fake-cursor {
    position: fixed;
    top: 0;
    left: 0;
    z-index: var(--zi-cursor);
    width: to-rem(10);
    height: to-rem(10);
    user-select: none;
    pointer-events: none;
    transform: translate3d(
      calc((100vw * var(--cursor-x) - 100%)),
      calc((100vh * var(--cursor-y) - 100%)),
      0
    );
    background: salmon;
  }
</style>
